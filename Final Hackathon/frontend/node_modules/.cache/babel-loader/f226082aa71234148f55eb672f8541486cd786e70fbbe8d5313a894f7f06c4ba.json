{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useRef } from 'react';\nimport { io } from 'socket.io-client';\nexport const useWebSocket = (url, onMessage) => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const socketRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const isConnecting = useRef(false);\n  useEffect(() => {\n    var _socketRef$current;\n    // Prevent multiple connections\n    if (isConnecting.current || (_socketRef$current = socketRef.current) !== null && _socketRef$current !== void 0 && _socketRef$current.connected) {\n      return;\n    }\n    isConnecting.current = true;\n\n    // Create socket connection with improved configuration\n    socketRef.current = io(url, {\n      transports: ['websocket', 'polling'],\n      timeout: 10000,\n      reconnectionAttempts: 3,\n      // Reduced from 5 to 3\n      reconnectionDelay: 4000,\n      // Increased delay\n      reconnectionDelayMax: 15000,\n      // Increased max delay\n      autoConnect: true,\n      forceNew: false\n    });\n    const socket = socketRef.current;\n\n    // Connection event handlers\n    socket.on('connect', () => {\n      console.log('✅ WebSocket connected to', url);\n      setIsConnected(true);\n      isConnecting.current = false;\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n        reconnectTimeoutRef.current = null;\n      }\n    });\n    socket.on('disconnect', reason => {\n      console.log('❌ WebSocket disconnected:', reason);\n      setIsConnected(false);\n      isConnecting.current = false;\n      if (reason === 'io server disconnect' || reason === 'transport close') {\n        console.log('🔄 Attempting to reconnect...');\n        reconnectTimeoutRef.current = setTimeout(() => {\n          if (!socket.connected && !isConnecting.current) {\n            socket.connect();\n          }\n        }, 4000);\n      }\n    });\n    socket.on('connect_error', error => {\n      console.error('❌ WebSocket connection error:', error.message);\n      setIsConnected(false);\n      isConnecting.current = false;\n    });\n    socket.on('reconnect', attemptNumber => {\n      console.log(`🔄 Reconnected after ${attemptNumber} attempts`);\n      setIsConnected(true);\n    });\n    socket.on('reconnect_error', error => {\n      console.error('❌ Reconnection failed:', error.message);\n    });\n    socket.on('reconnect_failed', () => {\n      console.error('❌ All reconnection attempts failed');\n      setIsConnected(false);\n    });\n\n    // Dashboard update handler\n    socket.on('dashboard-update', data => {\n      console.log('📊 Dashboard update received');\n      if (onMessage && typeof onMessage === 'function') {\n        onMessage(data);\n      }\n    });\n\n    // Cleanup function\n    return () => {\n      console.log('🧹 Cleaning up WebSocket connection');\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      socket.removeAllListeners();\n      if (socket.connected) {\n        socket.disconnect();\n      }\n      socketRef.current = null;\n      isConnecting.current = false;\n      setIsConnected(false);\n    };\n  }, [url]); // Only depend on URL, not onMessage to prevent recreation\n\n  // Handle onMessage changes without recreating the connection\n  useEffect(() => {\n    if (socketRef.current) {\n      socketRef.current.off('dashboard-update');\n      socketRef.current.on('dashboard-update', data => {\n        console.log('📊 Dashboard update received');\n        if (onMessage && typeof onMessage === 'function') {\n          onMessage(data);\n        }\n      });\n    }\n  }, [onMessage]);\n  const sendMessage = (event, data) => {\n    if (socketRef.current && socketRef.current.connected) {\n      socketRef.current.emit(event, data);\n      return true;\n    } else {\n      console.warn('⚠️ Cannot send message: WebSocket not connected');\n      return false;\n    }\n  };\n  const forceReconnect = () => {\n    if (socketRef.current && !isConnecting.current) {\n      console.log('🔄 Force reconnecting...');\n      socketRef.current.disconnect();\n      setTimeout(() => {\n        if (socketRef.current && !socketRef.current.connected) {\n          socketRef.current.connect();\n        }\n      }, 1000);\n    }\n  };\n  return {\n    isConnected,\n    sendMessage,\n    forceReconnect\n  };\n};\n_s(useWebSocket, \"1/yk6putHEkvcOJqbF/W6W4qYE8=\");","map":{"version":3,"names":["useEffect","useState","useRef","io","useWebSocket","url","onMessage","_s","isConnected","setIsConnected","socketRef","reconnectTimeoutRef","isConnecting","_socketRef$current","current","connected","transports","timeout","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","autoConnect","forceNew","socket","on","console","log","clearTimeout","reason","setTimeout","connect","error","message","attemptNumber","data","removeAllListeners","disconnect","off","sendMessage","event","emit","warn","forceReconnect"],"sources":["D:/Agent Ai/Agentic_AI_Workshop/Final Hackathon/frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useState, useRef } from 'react';\r\nimport { io } from 'socket.io-client';\r\n\r\nexport const useWebSocket = (url, onMessage) => {\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const socketRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const isConnecting = useRef(false);\r\n\r\n  useEffect(() => {\r\n    // Prevent multiple connections\r\n    if (isConnecting.current || socketRef.current?.connected) {\r\n      return;\r\n    }\r\n\r\n    isConnecting.current = true;\r\n\r\n    // Create socket connection with improved configuration\r\n    socketRef.current = io(url, {\r\n      transports: ['websocket', 'polling'],\r\n      timeout: 10000,\r\n      reconnectionAttempts: 3, // Reduced from 5 to 3\r\n      reconnectionDelay: 4000, // Increased delay\r\n      reconnectionDelayMax: 15000, // Increased max delay\r\n      autoConnect: true,\r\n      forceNew: false\r\n    });\r\n\r\n    const socket = socketRef.current;\r\n\r\n    // Connection event handlers\r\n    socket.on('connect', () => {\r\n      console.log('✅ WebSocket connected to', url);\r\n      setIsConnected(true);\r\n      isConnecting.current = false;\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n        reconnectTimeoutRef.current = null;\r\n      }\r\n    });\r\n\r\n    socket.on('disconnect', (reason) => {\r\n      console.log('❌ WebSocket disconnected:', reason);\r\n      setIsConnected(false);\r\n      isConnecting.current = false;\r\n      if (reason === 'io server disconnect' || reason === 'transport close') {\r\n        console.log('🔄 Attempting to reconnect...');\r\n        reconnectTimeoutRef.current = setTimeout(() => {\r\n          if (!socket.connected && !isConnecting.current) {\r\n            socket.connect();\r\n          }\r\n        }, 4000);\r\n      }\r\n    });\r\n\r\n    socket.on('connect_error', (error) => {\r\n      console.error('❌ WebSocket connection error:', error.message);\r\n      setIsConnected(false);\r\n      isConnecting.current = false;\r\n    });\r\n\r\n    socket.on('reconnect', (attemptNumber) => {\r\n      console.log(`🔄 Reconnected after ${attemptNumber} attempts`);\r\n      setIsConnected(true);\r\n    });\r\n\r\n    socket.on('reconnect_error', (error) => {\r\n      console.error('❌ Reconnection failed:', error.message);\r\n    });\r\n\r\n    socket.on('reconnect_failed', () => {\r\n      console.error('❌ All reconnection attempts failed');\r\n      setIsConnected(false);\r\n    });\r\n\r\n    // Dashboard update handler\r\n    socket.on('dashboard-update', (data) => {\r\n      console.log('📊 Dashboard update received');\r\n      if (onMessage && typeof onMessage === 'function') {\r\n        onMessage(data);\r\n      }\r\n    });\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      console.log('🧹 Cleaning up WebSocket connection');\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      socket.removeAllListeners();\r\n      if (socket.connected) {\r\n        socket.disconnect();\r\n      }\r\n      socketRef.current = null;\r\n      isConnecting.current = false;\r\n      setIsConnected(false);\r\n    };\r\n  }, [url]); // Only depend on URL, not onMessage to prevent recreation\r\n\r\n  // Handle onMessage changes without recreating the connection\r\n  useEffect(() => {\r\n    if (socketRef.current) {\r\n      socketRef.current.off('dashboard-update');\r\n      socketRef.current.on('dashboard-update', (data) => {\r\n        console.log('📊 Dashboard update received');\r\n        if (onMessage && typeof onMessage === 'function') {\r\n          onMessage(data);\r\n        }\r\n      });\r\n    }\r\n  }, [onMessage]);\r\n\r\n  const sendMessage = (event, data) => {\r\n    if (socketRef.current && socketRef.current.connected) {\r\n      socketRef.current.emit(event, data);\r\n      return true;\r\n    } else {\r\n      console.warn('⚠️ Cannot send message: WebSocket not connected');\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const forceReconnect = () => {\r\n    if (socketRef.current && !isConnecting.current) {\r\n      console.log('🔄 Force reconnecting...');\r\n      socketRef.current.disconnect();\r\n      setTimeout(() => {\r\n        if (socketRef.current && !socketRef.current.connected) {\r\n          socketRef.current.connect();\r\n        }\r\n      }, 1000);\r\n    }\r\n  };\r\n\r\n  return {\r\n    isConnected,\r\n    sendMessage,\r\n    forceReconnect\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}